{
  "language": "Solidity",
  "sources": {
    "contracts/Dchain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Dchain {\n    \n    struct ShipmentDetails {\n    ShipmentType shipmentType;\n    string origin;\n    string destination;\n    address supplier;\n    address transporter;\n    address retailer;\n    PaymentType paymentType;\n    uint256 amount;\n    bytes32 data;\n}\n    struct Shipment {\n        uint256 id;\n        uint256 paymentId;\n        string origin;\n        string destination;\n        ShipmentStatus status;\n        address supplier;\n        address transporter;\n        PaymentType paymentType;\n        address retailer;\n        uint256 amount;\n        ShipmentType shipmentType;\n        bytes32 data;\n    }\n\n    enum ShipmentStatus { Created, InTransit, Completed }\n    enum PaymentType { Escrowed, Preship, Postship }\n    enum PaymentStatus { Escrowed, Pending, Completed }\n    enum ShipmentType { Public, Private }\n\n    struct Payment {\n        uint256 id;\n        uint256 shipmentId;\n        uint256 amount;\n        PaymentStatus status;\n    }\n\n\n\n    // Mappings to store shipments and payments\n    mapping(uint256 => Shipment) public shipments;\n    mapping(uint256 => Payment) public payments;\n\n    // Counters for Shipment and Payment IDs\n    uint256 public shipmentCount = 0;\n    uint256 public privateShipmentCount = 0;\n    uint256 public paymentCount = 0;\n\n    // Events\n    event ShipmentCreated(uint256 id, ShipmentType shipmentType, string origin, string destination, address supplier, uint256 amount, uint256 timestamp);\n    event StatusUpdated(uint256 shipmentId, uint256 paymentId, ShipmentType shipmentType, ShipmentStatus status, address updatedBy, uint256 timestamp);\n    event PaymentMade(uint256 shipmentId, PaymentType paymentType, uint256 amount, address to, uint256 timestamp);\n    event PaymentReleased(uint256 shipmentId, uint256 amount, address to, uint256 timpestamp);\n    event Received(address sender, uint256 amount);\n    event Fallback(address sender, uint256 amount);\n    // Modifiers\n    modifier isValidShipment(ShipmentType shipmentType, string memory _origin, string memory _destination, address _supplier,  address _transporter, address _retailer, bytes32 _data) {\n        require(_transporter != address(0), \"Transporter is required\");\n        require(_retailer != address(0), \"Retailer is required\");\n        require(_supplier != address(0), \"Supplier is required\");\n        if(shipmentType == ShipmentType.Public) {\n            require(bytes(_origin).length > 0, \"Origin is required\");\n            require(bytes(_destination).length > 0, \"Destination is required\");\n        }else {\n            require(_data != bytes32(0), \"Data is required\");\n            require(bytes(_destination).length == 0, \"Destination must be empty\");\n            require(bytes(_origin).length == 0 , \"Origin must be empty\");\n        }\n        _;\n    }\n\n\n    // Payment Functions\n\n    function handlePayment(uint256 _shipmentId) external payable {\n        Shipment storage shipment = shipments[_shipmentId];\n        require(msg.value >= shipment.amount, \"Incorrect payment amount\"); // Ensure correct payment\n\n        paymentCount++;\n\n        if (shipment.paymentType == PaymentType.Preship) {\n            payable(shipment.supplier).transfer(shipment.amount);\n            payments[paymentCount]= Payment(paymentCount, shipment.id, shipment.amount, PaymentStatus.Completed);\n        }\n        if (shipment.paymentType == PaymentType.Postship) {\n            payable(shipment.supplier).transfer(shipment.amount);\n            payments[paymentCount]= Payment(paymentCount, shipment.id, shipment.amount, PaymentStatus.Completed);\n        }\n        if (shipment.paymentType == PaymentType.Escrowed) {\n            payments[paymentCount]= Payment(paymentCount, shipment.id, shipment.amount, PaymentStatus.Escrowed);\n        }\n        shipment.paymentId = paymentCount;\n        emit PaymentMade(_shipmentId, shipment.paymentType, shipment.amount, shipment.supplier, block.timestamp);\n    }\n\n    function releasePayment(uint256 _shipmentId) external {\n        Shipment storage shipment = shipments[_shipmentId];\n        Payment storage payment = payments[shipment.paymentId];\n        require (shipment.paymentType == PaymentType.Escrowed, \"Payment type is not escrowed\");\n        require(payment.status != PaymentStatus.Completed, \"Payment already released\");\n\n        // Transfer funds to the supplier\n        payable(shipment.supplier).transfer(shipment.amount);\n\n        payment.status = PaymentStatus.Completed;\n        \n        emit PaymentReleased(_shipmentId, shipment.amount, shipment.retailer, block.timestamp);\n    }\n\n    // Public Shipment Functions\nfunction createShipment(ShipmentDetails memory details) \n    isValidShipment(details.shipmentType, details.origin, details.destination, details.supplier, details.transporter, details.retailer, details.data) \n    public  \n{\n    shipmentCount++;\n    \n    shipments[shipmentCount] = Shipment(\n        shipmentCount,\n        0,\n        details.origin,\n        details.destination,\n        ShipmentStatus.Created,\n        msg.sender,\n        details.transporter,\n        details.paymentType,\n        details.retailer,\n        details.amount,\n        details.shipmentType,\n        details.data\n    );\n\n    emit ShipmentCreated(shipmentCount, details.shipmentType, details.origin, details.destination, msg.sender, details.amount, block.timestamp);\n}\n\n    function updateStatus(uint256 _shipmentId, ShipmentStatus _status) public {\n        require(_shipmentId > 0 && _shipmentId <= shipmentCount, \"Shipment does not exist\");\n        Shipment storage shipment = shipments[_shipmentId];\n        Payment storage payment = payments[shipment.paymentId];\n\n        require(msg.sender == shipment.supplier || msg.sender == shipment.transporter, \"Not authorized\");\n\n        if (_status == ShipmentStatus.Completed){\n            require(payment.status == PaymentStatus.Completed);\n        }\n        if (_status== ShipmentStatus.InTransit && shipment.paymentType == PaymentType.Escrowed){\n            require(payment.status == PaymentStatus.Escrowed);\n        }\n        if (_status == ShipmentStatus.InTransit && shipment.paymentType == PaymentType.Preship){\n            require(payment.status == PaymentStatus.Completed);\n        }\n        shipment.status = _status;\n        emit StatusUpdated(_shipmentId, payment.id, shipment.shipmentType, _status, msg.sender, block.timestamp);\n    }\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    fallback() external payable {\n        emit Fallback(msg.sender, msg.value);\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}